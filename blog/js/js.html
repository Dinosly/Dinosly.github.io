<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一、变量、执行上下文、作用域、内存、垃圾回收 | Dinosly的博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/dinosly.jpg">
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.aad7041b.css" as="style"><link rel="preload" href="/assets/js/app.03e23f57.js" as="script"><link rel="preload" href="/assets/js/2.7c609b98.js" as="script"><link rel="preload" href="/assets/js/7.1b272040.js" as="script"><link rel="prefetch" href="/assets/js/10.a491aaa7.js"><link rel="prefetch" href="/assets/js/11.aeaf59e2.js"><link rel="prefetch" href="/assets/js/3.4cb6f073.js"><link rel="prefetch" href="/assets/js/4.20844974.js"><link rel="prefetch" href="/assets/js/5.65018626.js"><link rel="prefetch" href="/assets/js/6.0217e9ba.js"><link rel="prefetch" href="/assets/js/8.6954b38f.js"><link rel="prefetch" href="/assets/js/9.546e81bb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.aad7041b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Dinosly的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="https://github.com/Dinosly" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="https://github.com/Dinosly" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Home</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/" class="sidebar-link">Welcome</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>从零搞懂js系列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/js/js.html" class="active sidebar-link">一、变量、执行上下文、作用域、内存、垃圾回收</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js/js.html#基本类型-和-引用类型" class="sidebar-link">基本类型 和 引用类型</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#复制变量值" class="sidebar-link">复制变量值</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#传递参数" class="sidebar-link">传递参数</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#检测类型" class="sidebar-link">检测类型</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#变量提升" class="sidebar-link">变量提升</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#函数提升" class="sidebar-link">函数提升</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#函数声明优先级高于变量声明" class="sidebar-link">函数声明优先级高于变量声明</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#可执行代码" class="sidebar-link">可执行代码</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#执行环境（执行上下文）" class="sidebar-link">执行环境（执行上下文）</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#内存泄漏：" class="sidebar-link">内存泄漏：</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#内存泄漏识别方法：" class="sidebar-link">内存泄漏识别方法：</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#weakmap-和-weakset：es6-弱引用" class="sidebar-link">weakMap 和 weakSet：ES6 弱引用</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#四种常见js内存泄漏：" class="sidebar-link">四种常见js内存泄漏：</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#概念：" class="sidebar-link">概念：</a></li><li class="sidebar-sub-header"><a href="/blog/js/js.html#两种常用垃圾收集方式：" class="sidebar-link">两种常用垃圾收集方式：</a></li></ul></li><li><a href="/blog/js/js2.html" class="sidebar-link">二、数据类型</a></li><li><a href="/blog/js/deepcopy.html" class="sidebar-link">三、深浅拷贝</a></li><li><a href="/blog/js/eventloop.html" class="sidebar-link">四、JavaScript执行顺序（EventLoop、Promise、async...await)</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/webpack/webpack.html" class="sidebar-link">webpack</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一、变量、执行上下文、作用域、内存、垃圾回收"><a href="#一、变量、执行上下文、作用域、内存、垃圾回收" class="header-anchor">#</a> 一、变量、执行上下文、作用域、内存、垃圾回收</h1> <h1 id="_1-变量"><a href="#_1-变量" class="header-anchor">#</a> 1.变量</h1> <ul><li><h2 id="基本类型-和-引用类型"><a href="#基本类型-和-引用类型" class="header-anchor">#</a> 基本类型 和 引用类型</h2> <ul><li>基本类型（6个）：
<ul><li>null，undefined，number，string，Boolean，==symbol==（）</li> <li>按值访问，可以操作保存在变量中实际的值</li> <li>基本类型值在内存中占据固定大小的空间，因此被保存在<strong>栈内存</strong>中；</li></ul></li> <li>引用类型（6个）：
<ul><li>对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function</li> <li>按引用访问，引用类型的值其实为保存在内存中的对象，不能直接操作对象的内存空间，通常操作对象的引用（指针，内存地址）</li> <li>引用类型的值是对象，保存在<strong>堆内存</strong>中</li></ul></li></ul></li> <li><h2 id="复制变量值"><a href="#复制变量值" class="header-anchor">#</a> 复制变量值</h2> <ul><li>基本类型：
<ul><li>在变量对象处创建新值，将新值复制给新变量，变量之间不会相互影响
<img src="https://img-blog.csdnimg.cn/20200330173003761.png" alt="在这里插入图片描述"></li></ul></li> <li>引用类型：
<ul><li>在变量对象处创建新值（引用对象的新值其实为指向对象内存地址的指针），将新值复制给新变量，新复制的值和原值都指向同一个对象，改变其中一个，改变的是共同指向的对象，所以另一个也会随之改变
<img src="https://img-blog.csdnimg.cn/20200330172947436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzA0NzE4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul></li> <li><h2 id="传递参数"><a href="#传递参数" class="header-anchor">#</a> 传递参数</h2> <ul><li>函数传参都是==按照值传递，不论参数是基本类型还是引用类型，都按值传递==（参数值不论是基本类型还是引用类型都是按值传递）</li> <li>基本类型:
<ul><li>将参数的值复制给局部变量</li></ul></li> <li>引用类型：
<ul><li>将参数的指针复制给局部变量，指向同一个对象</li> <li>函数内的局部变量修改引用对象的属性，外部参数也会随之改变</li></ul></li></ul></li> <li><h2 id="检测类型"><a href="#检测类型" class="header-anchor">#</a> 检测类型</h2> <ul><li>typeof 操作符
<ul><li>检测基本类型的值</li> <li>typeof null  // object 一般使用typeof需要先判断非null类型</li></ul></li> <li>instanceof 操作符
<ul><li>检测引用类型的值</li> <li>&quot;person&quot; instanceof Object  // false</li></ul></li></ul></li> <li><h2 id="变量提升"><a href="#变量提升" class="header-anchor">#</a> 变量提升</h2> <div class="language- extra-class"><pre class="language-text"><code>var a = 10;
//实际JavaScript执行顺序为
var a // 先为a赋值为undefined
a = 10; // 在执行a的真正赋值
</code></pre></div></li> <li><h2 id="函数提升"><a href="#函数提升" class="header-anchor">#</a> 函数提升</h2> <ul><li>定义函数的两种方式：
<ul><li>函数声明: function foo () {};
<ul><li>函数声明则会将函数提升至整个作用域的最顶部</li></ul></li> <li>函数表达式: var foo = function () {}.
<ul><li>函数表达式 类似于 变量声明 将foo提升至作用于顶部，赋值undefined</li></ul></li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>console.log(f1) // function f1(){}
function f1() {} // 函数声明
console.log(f2) // undefined
var f2 = function() {} // 函数表达式
</code></pre></div></li> <li><h2 id="函数声明优先级高于变量声明"><a href="#函数声明优先级高于变量声明" class="header-anchor">#</a> 函数声明优先级高于变量声明</h2> <ul><li>同一作用域下存在多个<strong>同名函数</strong>声明，后面的会替换前面的函数声明</li></ul></li></ul> <h1 id="_2-执行环境（执行上下文）及作用域"><a href="#_2-执行环境（执行上下文）及作用域" class="header-anchor">#</a> 2.执行环境（执行上下文）及作用域</h1> <ul><li><h2 id="可执行代码"><a href="#可执行代码" class="header-anchor">#</a> 可执行代码</h2> <ul><li><h4 id="javascript可执行代码分类："><a href="#javascript可执行代码分类：" class="header-anchor">#</a> JavaScript可执行代码分类：</h4> <ul><li>全局代码、函数代码、eval代码</li></ul></li></ul></li> <li><h2 id="执行环境（执行上下文）"><a href="#执行环境（执行上下文）" class="header-anchor">#</a> 执行环境（执行上下文）</h2> <ul><li><h4 id="什么是执行上下文："><a href="#什么是执行上下文：" class="header-anchor">#</a> 什么是执行上下文：</h4> <ul><li>javascript可执行代码<strong>被解析和执行时所在环境</strong>的抽象概念（其实就是一个执行环境）</li> <li>生成环境的同时定义了<strong>变量</strong>或<strong>函数</strong>有权访问的数据范围，也就是一个对象</li></ul></li> <li><h4 id="执行上下文三个重要属性："><a href="#执行上下文三个重要属性：" class="header-anchor">#</a> 执行上下文三个重要属性：</h4> <ul><li>变量对象 VO：
<ul><li>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</li></ul></li> <li>作用域链</li> <li>this</li></ul></li> <li><h4 id="执行上下文三种类型："><a href="#执行上下文三种类型：" class="header-anchor">#</a> 执行上下文三种类型：</h4> <ul><li>全局执行上下文（<strong>唯一</strong>）：js开始运行进入的第一个环境（也就是浏览器对象(即window对象)，也就是<strong>变量对象VO</strong>，并不能在js环境中直接访问）</li> <li>函数执行上下文 ：当函数被<strong>调用</strong>才会创建，每调用一次就创建一次新的执行上下文，被调用后会创建一个   <strong>活动对象AO</strong>，在当前执行上下文中的变量和函数该AO都可以访问的到</li> <li>eval函数执行上下文：eval函数执行其内部的代码会创建属于自己的执行上下文, 很少用而且不建议使用</li></ul></li> <li><h4 id="多个执行上下文如何运行："><a href="#多个执行上下文如何运行：" class="header-anchor">#</a> 多个执行上下文如何运行：</h4> <ul><li>单线程，一个一个执行</li> <li><strong>执行栈</strong>进行调度，LIFO(last-in first-out)后进先出，只有栈顶处于执行中，其他需等待</li> <li>js首次执行（<strong>全局执行上下文</strong>）-&gt; 有函数被调用时（js引擎创建一个<strong>函数执行上下文</strong>）-&gt; ...调用n次函数... -&gt; 栈顶的函数执行完毕，该函数对应的<strong>函数执行上下文</strong>出栈 -&gt; 浏览器窗口关闭（<strong>全局上下文执行</strong>出栈）。
<img src="https://img-blog.csdnimg.cn/20200331153207606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzA0NzE4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
执行栈调用关系如下图：<img src="https://img-blog.csdnimg.cn/20200331153246405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzA0NzE4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li> <li><h4 id="执行上下文的生命周期："><a href="#执行上下文的生命周期：" class="header-anchor">#</a> 执行上下文的生命周期：</h4></li></ul> <img src="https://img-blog.csdnimg.cn/20200331153747776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzA0NzE4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
- 创建阶段：<img src="https://img-blog.csdnimg.cn/20200331155156854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzA0NzE4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <ul><li>绑定this：</li> <li>词法环境：<strong>let 和 const 绑定</strong> <ul><li>词法环境分为：全局词法环境，函数词法环境</li> <li>词法环境组成：环境记录 + 对外部环境的引用
<ul><li>环境记录：存储变量和函数声明的实际位置</li> <li>对外部环境的引用：用于访问外部词法环境，上一级作用域链</li></ul></li></ul></li> <li>变量环境：<strong>var 绑定</strong> <ul><li>其余部分和词法环境一样
<img src="https://img-blog.csdnimg.cn/20200331173054339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzA0NzE4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><div class="language- extra-class"><pre class="language-text"><code>GlobalExectionContext = { // 全局执行上下文
    ThisBinding: &lt;Global Object&gt;,
    LexicalEnvironment: {   // 词法环境
    	EnvironmentRecord: {   // 环境记录
        	Type: &quot;Object&quot;,       // 全局环境
        	c: &lt; uninitialized &gt;,
                d: &lt; uninitialized &gt;,
        	fn: &lt; func &gt;
    	},
    	outer: &lt;null&gt;            // 外部环境引用
    },
    VariableEnvironment: {   // 变量环境
    	EnvironmentRecord: {   // 环境记录
    		Type: &quot;Object&quot;,
    		a: &lt; uninitialized &gt;,
    		b: &lt; uninitialized &gt;
    	},
    	outer: &lt;null&gt;  
    }
}
FunctionExectionContext = { // 函数执行上下文
    ThisBinding: &lt;Global Object&gt;, // this绑定window, 因为调用fn的是window对象
    LexicalEnvironment: {   // 词法环境
    	EnvironmentRecord: {   // 环境记录
    		Type: &quot;Object&quot;,       // 函数环境
    		Arguments: { 0: 10, 1: 20, length: 2 }
    	},
        outer: &lt; GlobalLexicalEnvironment &gt; // 全局环境的引用
    },
    VariableEnvironment: {   // 变量环境
    	EnvironmentRecord: {   // 环境记录
    		Type: &quot;Object&quot;,
    		g: &lt; uninitialized &gt;
    	},
    	outer: &lt; GlobalLexicalEnvironment &gt; // 全局环境的引用
    }
}
</code></pre></div></li></ul></li></ul></li></ul> <h1 id="_3-作用域、作用域链、闭包"><a href="#_3-作用域、作用域链、闭包" class="header-anchor">#</a> 3.作用域、作用域链、闭包</h1> <ul><li><h4 id="什么是作用域："><a href="#什么是作用域：" class="header-anchor">#</a> 什么是作用域：</h4> <ul><li>作用域是一个变量和函数的作用范围</li> <li>没有块级作用域（<strong>ES6之后有let 、 const 可以定义块级作用域</strong>）</li></ul></li> <li><h4 id="什么是作用域链："><a href="#什么是作用域链：" class="header-anchor">#</a> 什么是作用域链：</h4> <ul><li>访问一个变量时，解释器会首先在当前作用域查找标示符，没找到则去父作用域查找，一层一层向上找至全局作用域</li></ul></li> <li><h4 id="作用域链特点："><a href="#作用域链特点：" class="header-anchor">#</a> 作用域链特点：</h4> <ul><li>外部环境不能访问内部环境中的任何<strong>变量</strong>和<strong>函数</strong></li> <li>环境之间的联系是线性、有次序的，由内到外访问</li></ul></li> <li><h4 id="作用域链如何创建和变化："><a href="#作用域链如何创建和变化：" class="header-anchor">#</a> 作用域链如何创建和变化：</h4> <ul><li>创建：
<ul><li>在全局执行上下文创建时，全局对象中就定义了当前环境下涉及到的变量对象、函数对象的作用域标识</li></ul></li> <li>调用：
<ul><li>函数被调用，新的函数执行上下文创建，新的作用域对象（包括函数的参数，涉及到的变量）也被创建，此时形成了一个作用域链（新作用域对象 -&gt; 全局对象 ）</li></ul></li></ul></li> <li><h4 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h4> <ul><li>什么是闭包 ：
<ul><li><strong>闭包是指在当前作用域内总是能访问外部作用域中的变量的一个函数</strong></li></ul></li></ul></li></ul> <h1 id="_4-内存"><a href="#_4-内存" class="header-anchor">#</a> 4.内存</h1> <ul><li><h2 id="内存泄漏："><a href="#内存泄漏：" class="header-anchor">#</a> 内存泄漏：</h2> <ul><li>变量不被引用，一直占用内存空间</li></ul></li> <li><h2 id="内存泄漏识别方法："><a href="#内存泄漏识别方法：" class="header-anchor">#</a> 内存泄漏识别方法：</h2> <ul><li>浏览器：
<ul><li>开发者工具 -&gt; Memory -&gt; Select profiling type字段里面勾选 timeline -&gt; 录制 -&gt; 页面上进行各种操作，模拟用户的使用情况 -&gt; 点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况</li></ul></li> <li>命令行方法:
<ul><li>node提供的process.memoryUsage方法;</li> <li>判断内存泄漏，以heapUsed字段为准。</li> <li><div class="language- extra-class"><pre class="language-text"><code>  console.log(process.memoryUsage());
  // 输出
  { 
    rss: 27709440,		// resident set size，所有内存占用，包括指令区和堆栈
    heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的
    heapUsed: 3449392,	// 用到的堆的部分
    external: 8772 		// V8 引擎内部的 C++ 对象占用的内存
  }
</code></pre></div></li></ul></li></ul></li> <li><h2 id="weakmap-和-weakset：es6-弱引用"><a href="#weakmap-和-weakset：es6-弱引用" class="header-anchor">#</a> weakMap 和 weakSet：ES6 弱引用</h2> <ul><li>对于值的引用都是不计入垃圾回收机制</li> <li>如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。（不需要在使用完对象后对其进行释放，会自动回收它的内存）</li></ul></li> <li><h2 id="四种常见js内存泄漏："><a href="#四种常见js内存泄漏：" class="header-anchor">#</a> 四种常见js内存泄漏：</h2> <ul><li>1.函数内未定义的全局变量：
<ul><li>1.1为使用var、let、const定义的对象会挂载在window全局对象上</li> <li>1.2this引用：有些情况this会指向window全局对象</li> <li><strong>解决办法：</strong> 在 JavaScript 文件头部加上 'use strict'，使用严格模式避免意外的全局变量</li></ul></li> <li>2.计时器/回调函数</li> <li>3.脱离 DOM 的引用</li> <li>4.闭包</li></ul></li></ul> <h1 id="_5-内存-垃圾回收机制"><a href="#_5-内存-垃圾回收机制" class="header-anchor">#</a> 5.内存/垃圾回收机制</h1> <ul><li><h2 id="概念："><a href="#概念：" class="header-anchor">#</a> 概念：</h2> <ul><li><strong>执行环境</strong>找出那些不再继续使用的<strong>变量</strong>，然后释放其占用的<strong>内存</strong></li> <li>垃圾收集器会按照<strong>固定的时间间隔</strong>（或代码执行中预定的收集时间），周期性地执行这一操作</li> <li>当<strong>函数返回</strong>没有被引用的时候，函数就会被垃圾回收器回收</li></ul></li> <li><h2 id="两种常用垃圾收集方式："><a href="#两种常用垃圾收集方式：" class="header-anchor">#</a> 两种常用垃圾收集方式：</h2> <ul><li>标记清除：
<ul><li>i.变量进入执行环境则被标记</li> <li>ii.去除掉环境变量以及被环境变量引用的变量，把此时内存中留下的全部变量再次标记</li> <li>iii.删除这些二次标记的变量，回收内存空间</li></ul></li> <li>引用计数：
<ul><li>跟踪记录每个值被<strong>引用</strong>（<em>声明了一个变量并将一个引用类型值赋给该变量次数加1,如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1</em>）的次数</li> <li>会产生两个对象循环引用问题 ：
<ul><li>两个对象多次循环调用，占用大量的内存空间，又无法及时回收，导致内存泄漏</li></ul></li></ul></li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/" class="prev router-link-active">
        Welcome
      </a></span> <span class="next"><a href="/blog/js/js2.html">
        二、数据类型
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.03e23f57.js" defer></script><script src="/assets/js/2.7c609b98.js" defer></script><script src="/assets/js/7.1b272040.js" defer></script>
  </body>
</html>
