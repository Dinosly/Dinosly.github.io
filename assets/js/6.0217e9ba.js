(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{183:function(e,a,t){"use strict";t.r(a);var r=t(6),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"四、javascript执行顺序（eventloop、promise、async-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、javascript执行顺序（eventloop、promise、async-await"}},[e._v("#")]),e._v(" 四、JavaScript执行顺序（EventLoop、Promise、async...await)")]),e._v(" "),t("h2",{attrs:{id:"_1-javascript同步任务、异步任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-javascript同步任务、异步任务"}},[e._v("#")]),e._v(" 1.JavaScript同步任务、异步任务")]),e._v(" "),t("h3",{attrs:{id:"_1-1单线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1单线程"}},[e._v("#")]),e._v(" 1.1单线程")]),e._v(" "),t("ul",[t("li",[e._v("首先JS是"),t("strong",[e._v("单线程")]),e._v("语言（H5中提到的Web-Worker可以实现多线程效果等后续有精力在了解...）")]),e._v(" "),t("li",[e._v("单线程就意味着在按照执行栈中的任务顺序依次执行（"),t("strong",[e._v("同步任务")]),e._v("），如果单个任务执行时间过长，后面任务就要一直卡死，为了解决这个情况，"),t("strong",[e._v("异步任务")]),e._v("应运而生")])]),e._v(" "),t("h3",{attrs:{id:"_1-2同步任务、异步任务执行过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2同步任务、异步任务执行过程"}},[e._v("#")]),e._v(" 1.2同步任务、异步任务执行过程")]),e._v(" "),t("p",[e._v("[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-80WX0Qyl-1588935610497)(https://user-gold-cdn.xitu.io/2020/5/7/171ee64be4de4bc0?w=1148&h=960&f=png&s=401302)]")]),e._v(" "),t("ul",[t("li",[e._v("1.形成js执行栈，整个代码片为一个宏任务")]),e._v(" "),t("li",[e._v("2.按照执行栈中同步任务的顺序依次执行")]),e._v(" "),t("li",[e._v("3.碰到异步任务，就在任务队列中增加一个任务事件")]),e._v(" "),t("li",[e._v("4.等到执行栈为空，开始将任务队列中的异步任务结束等待，入栈执行（从任务队列里找到最先入队的任务）")]),e._v(" "),t("li",[e._v("5.结束执行，内存资源释放")]),e._v(" "),t("li",[t("strong",[e._v("依次循环2.3.4执行，这个过程称为EventLoop")])])]),e._v(" "),t("h2",{attrs:{id:"_2-eventloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-eventloop"}},[e._v("#")]),e._v(" 2.EventLoop")]),e._v(" "),t("h3",{attrs:{id:"_2-1宏任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1宏任务"}},[e._v("#")]),e._v(" 2.1宏任务")]),e._v(" "),t("ul",[t("li",[e._v("script全部代码")]),e._v(" "),t("li",[e._v("setTimeout")]),e._v(" "),t("li",[e._v("setInterval")]),e._v(" "),t("li",[e._v("setImmediate")]),e._v(" "),t("li",[e._v("I/O操作")]),e._v(" "),t("li",[e._v("UI界面渲染")])]),e._v(" "),t("h3",{attrs:{id:"_2-2微任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2微任务"}},[e._v("#")]),e._v(" 2.2微任务")]),e._v(" "),t("ul",[t("li",[e._v("Promise")]),e._v(" "),t("li",[e._v("Process.nextTick（Node独有）")]),e._v(" "),t("li",[e._v("MutationObserver")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.im/post/5c3d8956e51d4511dc72c200#heading-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("EventLoop介绍的非常详细，参考这个博主大大"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"_3-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-promise"}},[e._v("#")]),e._v(" 3.Promise")]),e._v(" "),t("h3",{attrs:{id:"_3-1-什么是promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-什么是promise"}},[e._v("#")]),e._v(" 3.1 什么是promise")]),e._v(" "),t("ul",[t("li",[e._v("异步编程的一种解决方式")]),e._v(" "),t("li",[e._v("一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果")]),e._v(" "),t("li",[e._v("从语法上说，Promise 是一个对象，从它可以获取异步操作的消息\n"),t("ul",[t("li",[e._v("对象状态不受外界影响，只会根据异步操作的结果决定\n"),t("ul",[t("li",[e._v("pending（进行中）")]),e._v(" "),t("li",[e._v("fulfilled（成功）")]),e._v(" "),t("li",[e._v("rejected（拒绝）")]),e._v(" "),t("li",[e._v("resolved（结束）")])])]),e._v(" "),t("li",[e._v("一旦改变，就不会再变\n"),t("ul",[t("li",[e._v("pending -> fulfilled")]),e._v(" "),t("li",[e._v("pending -> rejected")])])]),e._v(" "),t("li",[e._v("不能取消，一旦新建就会"),t("strong",[e._v("立即执行")])]),e._v(" "),t("li",[e._v("pending状态下无法得知进行状态（是刚开始还是快要完成了）")]),e._v(" "),t("li",[e._v("如果不设置回调函数，会在内部抛出错误")])])])]),e._v(" "),t("h3",{attrs:{id:"_3-2-promise-怎么用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-promise-怎么用"}},[e._v("#")]),e._v(" 3.2 promise 怎么用")]),e._v(" "),t("h4",{attrs:{id:"_3-2-1-promise对象是一个构造函数，用来生成promise实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-promise对象是一个构造函数，用来生成promise实例"}},[e._v("#")]),e._v(" 3.2.1 Promise对象是一个构造函数，用来生成Promise实例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const promise = new Promise((resolve,reject)=>{\n    if(//异步执行成功调用resolve函数){\n        resolve(value)\n    }else{\n        //异步执行失败调用reject函数\n        reject(value)\n    }\n})\n")])])]),t("ul",[t("li",[e._v("通常生成promise实例后，通过then方法指定resolved和rejected状态的回调函数")]),e._v(" "),t("li",[e._v("第一个参数为resolve的回调函数，必填（不指定执行成功后的回调函数在promise实例内会抛出异常），第二个参数reject的回调函数是可选的（一般不定义在then函数中，一般在then后链式调用catch）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//不推荐\npromise.then(\n     //第一个参数为resolve的回调函数，必填，第二个参数reject的回调函数是可选的，我们不推荐这样写\n    (value)=>{//resolve 成功},\n    (value)=>{//reject 失败}\n)\n//推荐写法\npromise.then(data=>{\n    //resolve\n}).catch(err=>{\n    //reject\n    //此处不catch的话，外部是不会有报错的，即不会捕获promise实例reject的状态\n})\n")])])]),t("ul",[t("li",[e._v("参数\n"),t("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/promise#Promise-%E7%9A%84%E5%90%AB%E4%B9%89",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise-的含义，参考阮一峰大大"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"_4-async-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-async-await"}},[e._v("#")]),e._v(" 4.async...await")]),e._v(" "),t("h3",{attrs:{id:"_4-1-什么是async"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-什么是async"}},[e._v("#")]),e._v(" 4.1 什么是async")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("async修饰的函数内会有异步任务，需要等待await修饰的函数执行完在继续执行其他语句")])]),e._v(" "),t("li",[e._v("async函数可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖")]),e._v(" "),t("li",[e._v("async函数内任何一个await语句返回reject，后面的语句都不会执行\n"),t("ul",[t("li",[e._v("解决办法：await放到try...catch语句中")])])]),e._v(" "),t("li",[e._v("本质为generator的语法糖")])]),e._v(" "),t("h3",{attrs:{id:"_4-2-什么是await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-什么是await"}},[e._v("#")]),e._v(" 4.2 什么是await")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("await返回一个promise对象，如果修饰的不是promise对象就返回其值")])]),e._v(" "),t("li",[t("p",[e._v("不能单独使用，必须配合async")])]),e._v(" "),t("li",[t("p",[e._v("不存在继发关系，最好让它们同时触发")]),e._v(" "),t("ul",[t("li",[e._v("实现方式：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let [foo, bar] = await Promise.all([getFoo(), getBar()]);\n")])])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);